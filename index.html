<!DOCTYPE html>

<html lang="zh-Hant">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>Markdown è¡¨æ ¼ç”¢ç”Ÿå™¨</title>
<style>
    body { font-family: "Segoe UI", sans-serif; padding: 20px; background: #f8f9fa; }
    h1 { color: #007bff; }
    select, button, input, textarea { font-size: 1em; margin: 5px; padding: 6px; }
    table { border-collapse: collapse; width: 100%; margin-top: 20px; background: #fff; }
    th, td { border: 1px solid #ccc; padding: 6px; text-align: left; }
    textarea { resize: both; }
    .btn-group { margin: 20px 0; display: flex; gap: 10px; flex-wrap: wrap; }
    .output-box { background: #eef; padding: 10px; white-space: pre-wrap; margin-top: 20px; }
  </style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.9.3/html2pdf.bundle.min.js"></script>
<script>
const formConfigs = {
  "ç¶²è·¯è³‡è¨Š": ["ç¶²è·¯è³‡è¨Š", "IP", "Subnet", "Gateway", "å‚™è¨»"],
  "é›»è…¦è¨­å‚™": ["é›»è…¦åç¨±", "ç®¡ç†è€…", "IP", "ç¶²å€", "TV or Anydesk", "å‚™è¨»"],
  "ç¶²è·¯è¨­å‚™": ["ç¶²è·¯è¨­å‚™", "ç®¡ç†è€…", "IP", "ç¶²å€", "å‚™è¨»"],
  "åˆ—å°è¨­å‚™": ["åˆ—å°è¨­å‚™", "ç®¡ç†è€…", "IP", "ç¶²å€", "å‚™è¨»"],
  "ç¶²è·¯æœå‹™": ["ç¶²è·¯æœå‹™", "å¸³è™Ÿ", "ç¶²å€", "å‚™è¨»"],
  "è»Ÿé«”è³‡ç”¢": ["ç”¢å“åç¨±", "ç”¢å“é‡‘é‘°", "é¡å‹", "æˆæ¬Šæ•¸é‡", "å®‰è£æ—¥", "ç”¨æˆ¶ç«¯", "å‚™è¨»"]
};

const textareaFields = ["å‚™è¨»", "ç”¢å“é‡‘é‘°"];
let pastedData = [];

function renderForm(data = []) {
  const formType = document.getElementById('formType').value;
  const fields = formConfigs[formType];
  const container = document.getElementById('dataForm');

  let html = `<table id="dataTable">
      <thead><tr>${fields.map(f => `<th>${f}</th>`).join('')}<th>æ“ä½œ</th></tr></thead><tbody>`;

  if (data.length > 0) {
    data.forEach(row => {
      html += `<tr>${fields.map((field, idx) =>
        textareaFields.includes(field)
          ? `<td><textarea rows="2">${row[idx] ?? ''}</textarea></td>`
          : `<td><input type="text" value="${row[idx] ?? ''}"></td>`
      ).join('')}<td><button onclick="deleteRow(this)">åˆªé™¤</button></td></tr>`;
    });
  } else {
    html += generateRow(fields);
  }

  html += `</tbody></table>`;
  container.innerHTML = html;
}

function generateRow(fields) {
  return `<tr>` + fields.map(field =>
    textareaFields.includes(field)
      ? `<td><textarea rows="2" placeholder="${field}"></textarea></td>`
      : `<td><input type="text" placeholder="${field}"></td>`
  ).join('') + `<td><button onclick="deleteRow(this)">åˆªé™¤</button></td></tr>`;
}

function addRow() {
  const fields = formConfigs[document.getElementById('formType').value];
  document.querySelector("#dataTable tbody").insertAdjacentHTML('beforeend', generateRow(fields));
}

function deleteRow(btn) {
  btn.closest('tr').remove();
}

function generateManualMarkdown() {
  const formType = document.getElementById('formType').value;
  const fields = formConfigs[formType];
  const rows = document.querySelectorAll("#dataTable tbody tr");

  let markdown = `| ${fields.join(" | ")} |\n`;
  markdown += `| ${fields.map(() => "---").join(" | ")} |\n`;

  rows.forEach(row => {
    const values = Array.from(row.querySelectorAll('input, textarea')).map(e => e.value.trim());
    markdown += `| ${values.join(" | ")} |\n`;
  });

  document.getElementById('output').textContent = markdown;
  updatePreview(fields, rows);
}

function updatePreview(fields, rows) {
  let html = `<table border="1" cellpadding="6" cellspacing="0" style="background: #fff; margin-top: 20px;"><thead><tr>${fields.map(f => `<th>${f}</th>`).join('')}</tr></thead><tbody>`;
  rows.forEach(row => {
    const values = Array.from(row.querySelectorAll('input, textarea')).map(e => e.value.trim());
    html += `<tr>${values.map(v => `<td>${v}</td>`).join('')}</tr>`;
  });
  html += `</tbody></table>`;
  document.getElementById('previewArea').innerHTML = html;
}

function clearAll() {
  renderForm();
  document.getElementById('output').textContent = '';
  document.getElementById('previewArea').innerHTML = '';
  pastedData = [];
}

// å•Ÿå‹•ç¶å®š
window.addEventListener("load", renderForm);
</script>
<style>
  .styled-button {
    background-color: #007bff;
    color: white;
    padding: 6px 14px;
    margin: 5px;
    border: none;
    border-radius: 5px;
    font-size: 0.95em;
    cursor: pointer;
    transition: background-color 0.2s ease;
  }
  .styled-button:hover {
    background-color: #0056b3;
  }
  .section {
    background: #f9fbfd;
    padding: 15px;
    border: 1px solid #ddd;
    border-radius: 8px;
    margin-bottom: 20px;
  }
  h2 {
    color: #333;
  }
  pre.output-box {
    background: #eef5ff;
    border: 1px solid #ccd;
    padding: 10px;
    border-radius: 5px;
  }
</style>
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
<script>
function exportMarkdownTextToXLSX() {
  const md = document.getElementById("mdTableInput").value.trim();
  if (!md) return alert("è«‹å…ˆè²¼ä¸Š Markdown è¡¨æ ¼ï¼");
  const lines = md.split("\n");
  const sheets = {};
  let currentTitle = "";
  let currentRows = [];

  lines.forEach(line => {
    if (line.startsWith("####")) {
      if (currentTitle && currentRows.length > 0) {
        sheets[currentTitle] = currentRows.slice();
      }
      currentTitle = line.replace(/^#+\s*/, "").trim().substring(0, 30);
      currentRows = [];
    } else if (line.startsWith("|") && line.includes("|")) {
      const cols = line.split("|").slice(1, -1).map(c => c.trim());
      currentRows.push(cols);
    }
  });
  if (currentTitle && currentRows.length > 0) {
    sheets[currentTitle] = currentRows.slice();
  }
  if (Object.keys(sheets).length === 0) return alert("æœªè§£æåˆ°è¡¨æ ¼å…§å®¹");

  const wb = XLSX.utils.book_new();
  Object.entries(sheets).forEach(([name, data]) => {
    const ws = XLSX.utils.aoa_to_sheet(data);
    XLSX.utils.book_append_sheet(wb, ws, name);
  });

  XLSX.writeFile(wb, "markdown-export.xlsx");
}
</script>
</head>
<body>
<h1>Markdown è¡¨æ ¼ç”¢ç”Ÿå™¨</h1>
<label for="formType">é¸æ“‡è¡¨å–®é¡å‹ï¼ˆæ‰‹å‹•è¼¸å…¥æ™‚ä½¿ç”¨ï¼‰ï¼š</label>
<select id="formType" onchange="renderForm()">
<option value="ç¶²è·¯è³‡è¨Š">ğŸŒ ç¶²è·¯è³‡è¨Š</option>
<option value="é›»è…¦è¨­å‚™">ğŸ’» é›»è…¦è¨­å‚™</option>
<option value="ç¶²è·¯è¨­å‚™">ğŸ“¡ ç¶²è·¯è¨­å‚™</option>
<option value="åˆ—å°è¨­å‚™">ğŸ–¨ï¸ åˆ—å°è¨­å‚™</option>
<option value="ç¶²è·¯æœå‹™">ğŸš€ ç¶²è·¯æœå‹™</option>
<option value="è»Ÿé«”è³‡ç”¢">ğŸ“š è»Ÿé«”è³‡ç”¢</option>
</select>
<div class="btn-group">
<button onclick="addRow()">â• æ–°å¢ä¸€ç­†ï¼ˆæ‰‹å‹•ï¼‰</button>
<button onclick="triggerImport()">ğŸ“‚ åŒ¯å…¥ Excel/JSON</button>
<button onclick="triggerPaste()">ğŸ“‘ å±€éƒ¨ EXCEL è¡¨æ ¼è³‡æ–™è½‰æ› md</button>
<button onclick="generateManualMarkdown()">âœï¸ æ‰‹å‹•è¼¸å…¥è½‰ Markdown</button>
<button onclick="copyMarkdown()">ğŸ“„ è¤‡è£½ Markdown çµæœ</button>
<button onclick="downloadMarkdown()">â¬‡ï¸ ä¸‹è¼‰ .md</button>
<button onclick="clearAll()">ğŸ§¹ é‡è¨­</button>
<button onclick="cleanMarkdown()">ğŸ§¹ è‡ªå‹•ä¿®æ­£ Markdown è¡¨æ ¼</button></div>
<div id="dataForm"></div>
<h2>Markdown çµæœï¼š</h2>
<pre class="output-box" id="output"></pre>
<h2>è³‡æ–™è¡¨æ ¼é è¦½ï¼š</h2>
<div id="previewArea"></div>
<!-- ğŸ“‹ Markdown è¡¨æ ¼è²¼ä¸Šå€ -->
<h2>ğŸ“‹ è²¼ä¸Š Markdown è¡¨æ ¼</h2>
<textarea id="mdTableInput" placeholder="è«‹è²¼ä¸Š Markdown è¡¨æ ¼..." rows="10" style="width: 100%;"></textarea>
<div style="margin-top:10px;">
<button onclick="convertMarkdownToTable()">ğŸ“‹ è½‰æ›ç‚ºè¡¨æ ¼åŒæ™‚è‡ªå‹•è£œé½Š | </button> <button class="styled-button" onclick="exportMarkdownTextToXLSX()">ğŸ“Š åŒ¯å‡º Excel</button>
<button onclick="exportMarkdownToPDF()">ğŸ–¨ï¸ åŒ¯å‡º PDF</button>
</div>
<div style="margin-top:10px;">
<button onclick="document.getElementById('jsonInput').click()">ğŸ“¥ åŒ¯å…¥ JSON</button>
<input accept=".json" id="jsonInput" onchange="loadFromJSON(event)" style="display:none" type="file"/>
</div>
<div id="mdTablePreview" style="margin-top:20px;"></div>
<!-- éš±è—ä¸Šå‚³èˆ‡è²¼ä¸Šå…ƒä»¶ -->
<input accept=".xlsx,.json" id="fileInput" onchange="handleFile(event)" type="file"/>
<textarea id="pasteArea" placeholder="è«‹ç›´æ¥è²¼ä¸Šè¡¨æ ¼è³‡æ–™ï¼Œç¬¬ä¸€åˆ—æœƒç•¶æ¨™é¡Œ" style="display:none; width:100%; height:150px; resize:both;"></textarea>
<div id="pasteStats" style="margin-top:5px; font-size:0.9em; color:#555;"></div>
<div id="pasteControl" style="display:none; margin:10px 0;">
<button onclick="processPastedData()">âœ… è¡¨æ ¼è²¼ä¸Šå®Œæˆï¼Œç”¢ç”Ÿ Markdown</button>
</div>
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
<script>
const formConfigs = {
  "ç¶²è·¯è³‡è¨Š": ["ç¶²è·¯è³‡è¨Š", "IP", "Subnet", "Gateway", "å‚™è¨»"],
  "é›»è…¦è¨­å‚™": ["é›»è…¦åç¨±", "ç®¡ç†è€…", "IP", "ç¶²å€", "TV or Anydesk", "å‚™è¨»"],
  "ç¶²è·¯è¨­å‚™": ["ç¶²è·¯è¨­å‚™", "ç®¡ç†è€…", "IP", "ç¶²å€", "å‚™è¨»"],
  "åˆ—å°è¨­å‚™": ["åˆ—å°è¨­å‚™", "ç®¡ç†è€…", "IP", "ç¶²å€", "å‚™è¨»"],
  "ç¶²è·¯æœå‹™": ["ç¶²è·¯æœå‹™", "å¸³è™Ÿ", "ç¶²å€", "å‚™è¨»"],
  "è»Ÿé«”è³‡ç”¢": ["ç”¢å“åç¨±", "ç”¢å“é‡‘é‘°", "é¡å‹", "æˆæ¬Šæ•¸é‡", "å®‰è£æ—¥", "ç”¨æˆ¶ç«¯", "å‚™è¨»"]
};

const textareaFields = ["å‚™è¨»", "ç”¢å“é‡‘é‘°"];
let pastedData = [];

function renderForm(data = []) {
  const formType = document.getElementById('formType').value;
  const fields = formConfigs[formType];
  const container = document.getElementById('dataForm');

  let html = `<table id="dataTable">
      <thead><tr>${fields.map(f => `<th>${f}</th>`).join('')}<th>æ“ä½œ</th></tr></thead><tbody>`;

  if (data.length > 0) {
    data.forEach(row => {
      html += `<tr>${fields.map((field, idx) => 
        textareaFields.includes(field)
          ? `<td><textarea rows="2">${row[idx] ?? ''}</textarea></td>`
          : `<td><input type="text" value="${row[idx] ?? ''}"></td>`
      ).join('')}<td><button onclick="deleteRow(this)">åˆªé™¤</button></td></tr>`;
    });
  } else {
    html += generateRow(fields);
  }

  html += `</tbody></table>`;
  container.innerHTML = html;
}

function generateRow(fields) {
  return `<tr>` + fields.map(field => 
    textareaFields.includes(field)
      ? `<td><textarea rows="2" placeholder="${field}"></textarea></td>`
      : `<td><input type="text" placeholder="${field}"></td>`
  ).join('') + `<td><button onclick="deleteRow(this)">åˆªé™¤</button></td></tr>`;
}

function addRow() {
  const fields = formConfigs[document.getElementById('formType').value];
  document.querySelector("#dataTable tbody").insertAdjacentHTML('beforeend', generateRow(fields));
}

function deleteRow(btn) {
  btn.closest('tr').remove();
}

function generateManualMarkdown() {
  const formType = document.getElementById('formType').value;
  const fields = formConfigs[formType];
  const rows = document.querySelectorAll("#dataTable tbody tr");

  let markdown = `| ${fields.join(" | ")} |\n`;
  markdown += `| ${fields.map(() => "---").join(" | ")} |\n`;

  rows.forEach(row => {
    const values = Array.from(row.querySelectorAll('input, textarea')).map(e => e.value.trim());
    markdown += `| ${values.join(" | ")} |\n`;
  });

  document.getElementById('output').textContent = markdown;
  updatePreview(fields, rows);
}

function copyMarkdown() {
  const text = document.getElementById('output').textContent;
  navigator.clipboard.writeText(text).then(() => alert('å·²è¤‡è£½åˆ°å‰ªè²¼ç°¿ï¼'));
}

function downloadMarkdown() {
  const text = document.getElementById('output').textContent;
  if (!text) return alert("è«‹å…ˆç”¢ç”Ÿå…§å®¹ï¼");
  const blob = new Blob(["\uFEFF" + text], {type: 'text/markdown;charset=utf-8;'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = "table.md";
  a.click();
  URL.revokeObjectURL(url);
}

function downloadCSV() {
  if (!pastedData.length) return alert('ç›®å‰åªæœ‰æ‰‹å‹•è³‡æ–™');
  const csv = pastedData.map(row => row.map(cell => `"${cell.replace(/"/g, '""')}"`).join(",")).join("\n");
  const blob = new Blob(["\uFEFF" + csv], {type: 'text/csv;charset=utf-8;'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = "table.csv";
  a.click();
  URL.revokeObjectURL(url);
}

function clearAll() {
  renderForm();
  document.getElementById('output').textContent = '';
  document.getElementById('previewArea').innerHTML = '';
  pastedData = [];
}

function triggerPaste() {
  document.getElementById('pasteArea').style.display = "block";
  document.getElementById('pasteArea').value = '';
  document.getElementById('pasteStats').innerHTML = '';
  document.getElementById('pasteControl').style.display = "block";
  document.getElementById('pasteArea').focus();
}

function handlePaste() {
  const pasteArea = document.getElementById('pasteArea');
  const statsArea = document.getElementById('pasteStats');
  const raw = pasteArea.value.trim();
  if (!raw) {
    statsArea.innerHTML = '';
    return;
  }
  const lines = raw.split('\n').filter(line => line.trim() !== "");
  if (lines.length === 0) {
    statsArea.innerHTML = '';
    return;
  }
  const lineHeight = 24;
  const minHeight = 150;
  const maxHeight = 600;
  pasteArea.style.height = Math.min(maxHeight, Math.max(minHeight, lines.length * lineHeight)) + "px";

  const firstRowCells = lines[0].split(/\t|\s{2,}/).filter(cell => cell !== "");
  statsArea.innerHTML = `åµæ¸¬åˆ° ${lines.length} åˆ—ï¼Œ${firstRowCells.length} æ¬„`;
}

function processPastedData() {
  const pasteArea = document.getElementById('pasteArea');
  const statsArea = document.getElementById('pasteStats');
  const controlArea = document.getElementById('pasteControl');

  const raw = pasteArea.value.trim();
  if (!raw) return alert("è«‹å…ˆè²¼ä¸Šè³‡æ–™ï¼");

  const lines = raw.split('\n').map(line => line.split(/\t|\s{2,}/).map(cell => cell.trim()));
  pastedData = lines;

  generatePastedMarkdown();

  pasteArea.style.display = "none";
  statsArea.innerHTML = '';
  controlArea.style.display = "none";
}

function generatePastedMarkdown() {
  let markdown = `| ${pastedData[0].join(' | ')} |\n`;
  markdown += `| ${pastedData[0].map(() => "---").join(' | ')} |\n`;
  pastedData.slice(1).forEach(row => {
    markdown += `| ${row.join(' | ')} |\n`;
  });

  document.getElementById('output').textContent = markdown;

  let html = `<table border="1" cellpadding="6" cellspacing="0" style="background:#fff;margin-top:20px;"><thead><tr>${pastedData[0].map(h => `<th>${h}</th>`).join('')}</tr></thead><tbody>`;
  pastedData.slice(1).forEach(row => {
    html += `<tr>${row.map(c => `<td>${c}</td>`).join('')}</tr>`;
  });
  html += `</tbody></table>`;

  document.getElementById('previewArea').innerHTML = html;
}

function updatePreview(fields, rows) {
  let html = `<table border="1" cellpadding="6" cellspacing="0" style="background: #fff; margin-top: 20px;"><thead><tr>${fields.map(f => `<th>${f}</th>`).join('')}</tr></thead><tbody>`;
  rows.forEach(row => {
    const values = Array.from(row.querySelectorAll('input, textarea')).map(e => e.value.trim());
    html += `<tr>${values.map(v => `<td>${v}</td>`).join('')}</tr>`;
  });
  html += `</tbody></table>`;
  document.getElementById('previewArea').innerHTML = html;
}

function triggerImport() {
  document.getElementById('fileInput').click();
}

function handleFile(event) {
  const file = event.target.files[0];
  if (!file) return;
  const reader = new FileReader();

  if (file.name.endsWith('.json')) {
    reader.onload = e => {
      pastedData = JSON.parse(e.target.result);
      generatePastedMarkdown();
    };
    reader.readAsText(file);
  } else if (file.name.endsWith('.xlsx')) {
    reader.onload = e => {
      const data = new Uint8Array(e.target.result);
      const workbook = XLSX.read(data, {type: 'array'});
      const sheet = workbook.Sheets[workbook.SheetNames[0]];
      pastedData = XLSX.utils.sheet_to_json(sheet, {header:1});
      generatePastedMarkdown();
    };
    reader.readAsArrayBuffer(file);
  } else {
    alert("è«‹ä¸Šå‚³ .xlsx æˆ– .json æª”æ¡ˆï¼");
  }
}


function convertMarkdownToTable() {
  const raw = document.getElementById('mdTableInput').value.trim();
  if (!raw.startsWith('|')) return alert("è«‹è²¼ä¸Šæ­£ç¢ºçš„ Markdown è¡¨æ ¼æ ¼å¼");

  const lines = raw.split('\n').filter(l => l.trim().startsWith('|'));
  let data = lines.map(line =>
    line.trim().split('|').slice(1, -1).map(cell => cell.trim())
  );

  const colCount = data[0]?.length || 0;
  data = data.map(row => {
    while (row.length < colCount) row.push('');
    return row;
  });

  window._mdParsedTable = data;

  let html = "<table border='1' style='width:100%; background:#fff'><thead><tr>" +
    data[0].map(h => `<th>${h}</th>`).join('') + "</tr></thead><tbody>";

  data.slice(2).forEach(row => {
    html += "<tr>" + row.map(c => `<td>${c}</td>`).join('') + "</tr>";
  });

  html += "</tbody></table>";
  document.getElementById('mdTablePreview').innerHTML = html;
}

function exportMarkdownToCSV() {
  if (!window._mdParsedTable) return alert("è«‹å…ˆè½‰æ› Markdown è¡¨æ ¼ï¼");
  const rows = window._mdParsedTable.slice(2);
  const csv = [window._mdParsedTable[0], ...rows]
    .map(r => r.map(cell => `"${cell.replace(/"/g, '""')}"`).join(','))
    .join('\n');
  const blob = new Blob(['\uFEFF' + csv], { type: 'text/csv;charset=utf-8;' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'markdown-table.csv';
  a.click();
}

function exportMarkdownToPDF() {
  if (!window._mdParsedTable) return alert("è«‹å…ˆè½‰æ› Markdown è¡¨æ ¼ï¼");
  const printWindow = window.open('', '', 'width=800,height=600window.addEventListener("load", renderForm);
</script>
<script>
function copyMarkdown() {
  const text = document.getElementById('output').textContent;
  navigator.clipboard.writeText(text).then(() => alert('å·²è¤‡è£½åˆ°å‰ªè²¼ç°¿ï¼'));
}

function downloadMarkdown() {
  const text = document.getElementById('output').textContent;
  if (!text) return alert("è«‹å…ˆç”¢ç”Ÿå…§å®¹ï¼");
  const blob = new Blob(["\uFEFF" + text], {type: 'text/markdown;charset=utf-8;'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = "table.md";
  a.click();
  URL.revokeObjectURL(url);
}

function downloadCSV() {
  let data = [];
  if (window._mdParsedTable) {
    data = window._mdParsedTable;
  } else {
    const table = document.querySelector("#dataTable tbody");
    if (!table) return alert("æ²’æœ‰è³‡æ–™å¯åŒ¯å‡ºï¼");
    const rows = table.querySelectorAll("tr");
    data = [
      formConfigs[document.getElementById('formType').value],
      ...Array.from(rows).map(tr =>
        Array.from(tr.querySelectorAll('input, textarea')).map(td => td.value.trim())
      )
    ];
  }

  const csv = data.map(row =>
    row.map(cell => `"${cell.replace(/"/g, '""')}"`).join(",")
  ).join("\n");
  const blob = new Blob(["\uFEFF" + csv], {type: 'text/csv;charset=utf-8;'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = "table.csv";
  a.click();
  URL.revokeObjectURL(a.href);
}

function triggerPaste() {
  document.getElementById('pasteArea').style.display = "block";
  document.getElementById('pasteArea').value = '';
  document.getElementById('pasteStats').innerHTML = '';
  document.getElementById('pasteControl').style.display = "block";
  document.getElementById('pasteArea').focus();
}

function triggerImport() {
  document.getElementById('fileInput').click();
}
</script>
<script>
function processPastedData() {
  const pasteArea = document.getElementById('pasteArea');
  const statsArea = document.getElementById('pasteStats');
  const controlArea = document.getElementById('pasteControl');

  const raw = pasteArea.value.trim();
  if (!raw) return alert("è«‹å…ˆè²¼ä¸Šè³‡æ–™ï¼");

  const lines = raw.split('\n').filter(line => line.trim() !== '');
  if (lines.length < 2) return alert("è²¼ä¸Šçš„è³‡æ–™æ ¼å¼ä¸è¶³");

  const parsed = lines.map(line =>
    line.split(/\t|\s{2,}/).map(cell => cell.trim())
  );

  // è£œç©ºæ¬„ä½åˆ°æ¯åˆ—ä¸€è‡´é•·åº¦
  const colCount = parsed[0].length;
  const normalized = parsed.map(row => {
    while (row.length < colCount) row.push('');
    return row;
  });

  window._mdParsedTable = normalized;

  // ç”¢ç”Ÿ markdown
  let md = `| ${normalized[0].join(' | ')} |\n`;
  md += `| ${normalized[0].map(() => '---').join(' | ')} |\n`;
  normalized.slice(1).forEach(row => {
    md += `| ${row.join(' | ')} |\n`;
  });
  document.getElementById('output').textContent = md;

  // ç”¢ç”Ÿé è¦½
  let html = `<table border="1" cellpadding="6" cellspacing="0" style="background:#fff;margin-top:20px;"><thead><tr>`;
  html += normalized[0].map(h => `<th>${h}</th>`).join('') + "</tr></thead><tbody>";
  normalized.slice(1).forEach(row => {
    html += "<tr>" + row.map(cell => `<td>${cell}</td>`).join('') + "</tr>";
  });
  html += "</tbody></table>";
  document.getElementById('previewArea').innerHTML = html;

  // é—œé–‰è²¼ä¸Šå€
  pasteArea.style.display = "none";
  statsArea.innerHTML = '';
  controlArea.style.display = "none";
}
</script>
<script>
function exportMarkdownToPDF() {
  if (!window._mdParsedTable) return alert("è«‹å…ˆè½‰æ› Markdown è¡¨æ ¼ï¼");
  const element = document.getElementById('mdTablePreview');

  const opt = {
    margin: 10,
    filename: 'markdown-table.pdf',
    html2canvas: {
      scale: 2,
      useCORS: true,
      allowTaint: true
    },
    jsPDF: {
      unit: 'mm',
      format: 'a4',
      orientation: 'landscape'
    },
    pagebreak: {
      mode: ['avoid-all', 'css', 'legacy']
    }
  };

  html2pdf().set(opt).from(element).save();
}
</script>
<script>
function convertMarkdownToTable() {
  const raw = document.getElementById('mdTableInput').value.trim();
  if (!raw) return alert("è«‹è²¼ä¸Šæœ‰æ•ˆçš„ Markdown è³‡æ–™");

  const lines = raw.split("\n");
  const groups = [];
  let currentTitle = null;
  let currentBlock = [];

  for (const line of lines) {
    if (line.startsWith("#### ")) {
      if (currentTitle && currentBlock.length > 0) {
        groups.push({ title: currentTitle, lines: currentBlock });
      }
      currentTitle = line.replace(/^####\s+/, "").trim();
      currentBlock = [];
    } else {
      currentBlock.push(line);
    }
  }
  if (currentTitle && currentBlock.length > 0) {
    groups.push({ title: currentTitle, lines: currentBlock });
  }

  let finalMarkdown = "";
  let previewHTML = "";
  let flatParsed = [];

  groups.forEach(group => {
    const content = group.lines.join("\n");
    const tableLines = content.split("\n").filter(l => l.includes("|"));
    const rows = tableLines.map(line => {
      let txt = line.trim();
      if (!txt.startsWith("|")) txt = "|" + txt;
      if (!txt.endsWith("|")) txt = txt + "|";
      const fields = txt.split("|").slice(1, -1).map(cell => cell.trim());
      const joined = fields.join("").toLowerCase();
      // æ¿¾æ‰åƒæ˜¯ '---' çš„æ¬„ä½è¡Œ
      if (joined.replace(/-/g, "") === "") return null;
      return fields.every(cell => cell === "") ? null : fields;
    }).filter(r => r !== null);

    if (rows.length < 2) return; // å¿…é ˆè‡³å°‘æœ‰ header + ä¸€åˆ—è³‡æ–™

    const colCount = Math.max(...rows.map(r => r.length));
    const normalized = rows.map(row => {
      while (row.length < colCount) row.push("");
      return row;
    });

    const header = normalized[0];
    const dataRows = normalized.slice(1);

    // Markdown è¼¸å‡º
    finalMarkdown += `#### ${group.title}\n`;
    finalMarkdown += `| ${header.join(" | ")} |\n`;
    finalMarkdown += `| ${header.map(() => "---").join(" | ")} |\n`;
    dataRows.forEach(row => {
      finalMarkdown += `| ${row.join(" | ")} |\n`;
    });
    finalMarkdown += "\n";

    // é è¦½ HTML
    previewHTML += `<h4>${group.title}</h4>`;
    previewHTML += "<table border='1' cellpadding='6' cellspacing='0' style='background:#fff;margin-top:10px;'><thead><tr>";
    previewHTML += header.map(h => `<th>${h}</th>`).join("") + "</tr></thead><tbody>";
    dataRows.forEach(row => {
      previewHTML += "<tr>" + row.map(cell => `<td>${cell}</td>`).join("") + "</tr>";
    });
    previewHTML += "</tbody></table>";

    flatParsed = flatParsed.concat(dataRows); // åƒ…è¨˜éŒ„è³‡æ–™è¡Œï¼Œä¸åŒ…å«è¡¨é ­èˆ‡åˆ†éš”è¡Œ
  });

  window._mdParsedTable = flatParsed;
  document.getElementById("output").textContent = finalMarkdown;
  document.getElementById("mdTablePreview").innerHTML = previewHTML;
}
</script>
<script>
function exportMarkdownToCSV() {
  if (!window._mdGroupedTables || !Array.isArray(window._mdGroupedTables)) {
    return alert("è«‹å…ˆè½‰æ› Markdown è¡¨æ ¼ï¼");
  }
  let csv = "";
  window._mdGroupedTables.forEach(group => {
    csv += `\n# ${group.title}\n`;
    csv += group.data.map(row =>
      row.map(cell => \`"\${cell.replace(/"/g, '""')}"\`).join(",")
    ).join("\n") + "\n";
  });
  const blob = new Blob(["\uFEFF" + csv], { type: "text/csv;charset=utf-8;" });
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "markdown-table.csv";
  a.click();
  URL.revokeObjectURL(a.href);
}

function saveAsJSON() {
  if (!window._mdGroupedTables || !Array.isArray(window._mdGroupedTables)) {
    return alert("è«‹å…ˆè½‰æ› Markdown è¡¨æ ¼ï¼");
  }
  const blob = new Blob([JSON.stringify({
    type: "grouped",
    data: window._mdGroupedTables
  }, null, 2)], { type: "application/json" });
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "table-data.json";
  a.click();
  URL.revokeObjectURL(a.href);
}
</script>
<script>
function handleFile(event) {
  const file = event.target.files[0];
  if (!file) return;
  const reader = new FileReader();

  if (file.name.endsWith('.json')) {
    reader.onload = e => {
      try {
        const json = JSON.parse(e.target.result);
        if (json.type === 'grouped' && Array.isArray(json.data)) {
          window._mdGroupedTables = json.data;
          const lines = json.data.map(group => {
            const header = group.data[0];
            const sep = header.map(() => "---");
            const rows = group.data.slice(1);
            let md = `#### ${group.title}\n`;
            md += `| ${header.join(" | ")} |\n`;
            md += `| ${sep.join(" | ")} |\n`;
            md += rows.map(r => `| ${r.join(" | ")} |`).join("\n");
            return md;
          }).join("\n\n");
          document.getElementById("mdTableInput").value = lines;
          alert("JSON è¼‰å…¥å®Œæˆï¼Œè«‹é»ã€è½‰æ›ç‚ºè¡¨æ ¼ã€");
        } else {
          alert("ä¸æ”¯æ´çš„ JSON æ ¼å¼ï¼");
        }
      } catch {
        alert("JSON ç„¡æ³•è§£æï¼");
      }
    };
    reader.readAsText(file);
  }

  if (file.name.endsWith('.xlsx')) {
    reader.onload = e => {
      const data = new Uint8Array(e.target.result);
      const workbook = XLSX.read(data, { type: 'array' });
      const sheet = workbook.Sheets[workbook.SheetNames[0]];
      const rows = XLSX.utils.sheet_to_json(sheet, { header: 1 });
      if (!rows.length) return alert("Excel ç„¡è³‡æ–™");
      const headers = rows[0];
      const sep = headers.map(() => "---");
      const body = rows.slice(1);
      let md = `#### Excel åŒ¯å…¥\n`;
      md += `| ${headers.join(" | ")} |\n`;
      md += `| ${sep.join(" | ")} |\n`;
      body.forEach(r => {
        while (r.length < headers.length) r.push("");
        md += `| ${r.join(" | ")} |\n`;
      });
      document.getElementById("mdTableInput").value = md;
      alert("Excel åŒ¯å…¥å®Œæˆï¼Œè«‹é»ã€è½‰æ›ç‚ºè¡¨æ ¼ã€");
    };
    reader.readAsArrayBuffer(file);
  }
}
</script>
<script>
function clearAll() {
  renderForm();
  document.getElementById('output').textContent = '';
  document.getElementById('previewArea').innerHTML = '';
  if (document.getElementById('mdTableInput')) {
    document.getElementById('mdTableInput').value = '';
  }
  if (document.getElementById('mdTablePreview')) {
    document.getElementById('mdTablePreview').innerHTML = '';
  }
  if (document.getElementById('fileInput')) {
    document.getElementById('fileInput').value = '';
  }
  window._mdParsedTable = [];
  window._mdGroupedTables = [];
}
</script>
<script>
function cleanMarkdown() {
  const text = document.getElementById("mdTableInput").value.trim();
  if (!text.includes("|")) {
    alert("è«‹å…ˆè²¼ä¸Š Markdown è¡¨æ ¼è³‡æ–™ï¼");
    return;
  }
  const lines = text.split("\n").filter(l => l.trim() !== "");
  const tables = [];
  let block = [];
  let colCount = 0;
  for (let line of lines) {
    if (line.includes("|")) {
      block.push(line.trim());
    } else {
      if (block.length > 1) {
        tables.push(block);
        block = [];
      }
    }
  }
  if (block.length > 1) tables.push(block);

  let output = "";
  for (let tbl of tables) {
    const header = tbl[0].split("|").filter(Boolean).map(c => c.trim());
    colCount = header.length;
    output += "| " + header.join(" | ") + " |\n";
    output += "| " + header.map(() => "---").join(" | ") + " |\n";

    for (let i = 2; i < tbl.length; i++) {
      let row = tbl[i].split("|").filter(Boolean).map(c => c.trim());
      if (row.length > colCount) {
        const extra = row.slice(colCount).join(" / ");
        row = row.slice(0, colCount - 1).concat((row[colCount - 1] || "") + " / " + extra);
      }
      while (row.length < colCount) row.push("");
      output += "| " + row.slice(0, colCount).join(" | ") + " |\n";
    }
    output += "\n";
  }
  document.getElementById("mdTableInput").value = output.trim();
  alert("âœ… Markdown è¡¨æ ¼å·²ä¿®æ­£å®Œæˆï¼Œé¡å¤–è³‡æ–™å·²ä½µå…¥å‚™è¨»ï¼");
}
</script><div style="margin-top: 40px; font-size: 0.85em; color: #555; border-top: 1px solid #ccc; padding-top: 10px;">Â© 2025 OU SHOU SHUO â€” Released under the <a href="https://opensource.org/licenses/MIT" target="_blank">MIT License</a>.</div></body>
</html>
